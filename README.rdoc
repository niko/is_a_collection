== is_a_collection

A small gem that adds #find and #all to a class to keep track of its instances:
  
  class A
    is_a_collection
    
    def initialize(*args)
      super
    end
    
    def id
      object_id
    end
  end
  
  a = A.new
  A.all             # => [#<A:0x00000101b9d668>]
  b = A.new
  A.all             # => [#<A:0x00000101b9d668>, #<A:0x00000101b9ce48>]
  A.find(a.id)      # => #<A:0x00000101b9d668>
  a.destroy
  A.all             # => [#<A:0x00000101b9ce48>]

As you can see: By default is_a_collection looks for an #id method and uses that for its index. But you can tell what method to use, #name in this example:

  class B
    attr_reader :name
    is_a_collection :name
    
    def initialize(name)
      @name = name
      add_to_collection
    end
    def destroy
      remove_from_collection
    end
  end
  
  a = B.new('foo')
  B.all             # => [#<B:0x00000101b9b778 @name="foo">]
  b = B.new('bar')
  B.all             # => [#<B:0x00000101b9b778 @name="foo">, #<B:0x00000101b9b138 @name="bar">]
  B.find('foo')     # => #<B:0x00000101b9b778 @name="foo">
  a.destroy
  B.all             # => [#<B:0x00000101b9b138 @name="bar">]


is_a_collection hooks itself into #initialize and #destroy and calls its own #add_to_collection respectivly #remove_from_collection there. This means, if you define #initialize or #destroy in your class (and not in one of its superclasses), you either have to explicitly call super (to give is_a_collection a chance to do its work) or call #add_to_collection and #remove_from_collection yourself.

== It doesn't work

Did you call super in #initialize? Yes? I'm glad to help: Issues[https://github.com/niko/is_a_collection/issues]
